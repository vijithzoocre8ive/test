"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
exports.concurrency = 0;
class MultiError extends Error {
    constructor(list) {
        super(`${list.length} errors`);
        this.list = list;
    }
}
exports.MultiError = MultiError;
function each(list, action, options) {
    return __awaiter(this, void 0, Promise, function* () {
        if (list && list.length > 0) {
            list = list.slice(0);
            var size = options ? options.concurrency : exports.concurrency;
            if (size === 0)
                size = list.length;
            yield pool(size, () => __awaiter(this, void 0, void 0, function* () {
                if (list.length > 0)
                    yield action(list.shift());
                return list.length > 0;
            }));
        }
    });
}
exports.each = each;
function filter(list, action, options) {
    return __awaiter(this, void 0, Promise, function* () {
        var result = [];
        if (list && list.length > 0) {
            var clone = list.slice(0);
            var size = options ? options.concurrency : exports.concurrency;
            if (size === 0)
                size = clone.length;
            var i = 0;
            yield pool(size, () => __awaiter(this, void 0, void 0, function* () {
                if (clone.length > 0) {
                    var j = i++;
                    var value = clone.shift();
                    if (yield action(value, i, clone))
                        result[j] = value;
                }
                return clone.length > 0;
            }));
        }
        return result.filter(value => value !== undefined);
    });
}
exports.filter = filter;
function invoke(list, options) {
    return __awaiter(this, void 0, Promise, function* () {
        if (list && list.length > 0) {
            list = list.slice(0);
            var size = options ? options.concurrency : exports.concurrency;
            if (size === 0)
                size = list.length;
            yield pool(size, () => __awaiter(this, void 0, void 0, function* () {
                if (list.length > 0)
                    yield list.shift().call(this);
                return list.length > 0;
            }));
        }
    });
}
exports.invoke = invoke;
function map(list, action, options) {
    return __awaiter(this, void 0, Promise, function* () {
        var result = [];
        if (list && list.length > 0) {
            list = list.slice(0);
            var size = options ? options.concurrency : exports.concurrency;
            if (size === 0)
                size = list.length;
            var i = 0;
            var result = [];
            yield pool(size, () => __awaiter(this, void 0, void 0, function* () {
                if (list.length > 0) {
                    var j = i++;
                    result[j] = yield action(list.shift());
                }
                return list.length > 0;
            }));
        }
        return result;
    });
}
exports.map = map;
function pool(size, task) {
    return __awaiter(this, void 0, Promise, function* () {
        var active = 0;
        var done = false;
        var errors = [];
        return new Promise((resolve, reject) => {
            next();
            function next() {
                while (active < size && !done) {
                    active += 1;
                    task()
                        .then(more => {
                        if (--active === 0 && (done || !more))
                            errors.length === 0 ? resolve() : reject(new MultiError(errors));
                        else if (more)
                            next();
                        else
                            done = true;
                    })
                        .catch(err => {
                        errors.push(err);
                        done = true;
                        if (--active === 0)
                            reject(new MultiError(errors));
                    });
                }
            }
        });
    });
}
exports.pool = pool;
//# sourceMappingURL=index.js.map